# 70. Climbing Stairs

## Problem Statement

You are climbing a staircase. It takes **`n` steps** to reach the top.

Each time, you can either climb **1 step** or **2 steps**.

**Question:**
How many **distinct ways** can you climb to the top?

---

## Examples

### Example 1

```
Input:  n = 2
Output: 2
```

**Explanation**

```
1 step + 1 step
2 steps
```

---

### Example 2

```
Input:  n = 3
Output: 3
```

**Explanation**

```
1 step + 1 step + 1 step
1 step + 2 steps
2 steps + 1 step
```

---

## Constraints

```
1 <= n <= 45
```

---

## Why DP should be applied here?

1. **Choice at each step**

   * From step `n`, you can come from `n-1` or `n-2`
2. **Overlapping subproblems**

   * Same states (e.g., `ways(2)`, `ways(1)`) are recalculated multiple times
3. **Optimal substructure**

   * `ways(n)` depends on optimal solutions of smaller states

---

## Recursion Tree (Without DP)

### Example: `n = 4`

```
ways(4)
â”œâ”€â”€ ways(3)
â”‚   â”œâ”€â”€ ways(2)
â”‚   â”‚   â”œâ”€â”€ ways(1)
â”‚   â”‚   â””â”€â”€ ways(0)
â”‚   â””â”€â”€ ways(1)
â””â”€â”€ ways(2)
    â”œâ”€â”€ ways(1)
    â””â”€â”€ ways(0)
```

ðŸ”´ **Problem:**
`ways(2)` and `ways(1)` are computed **multiple times**

---

## Base Case Explanation

```
dp[0] = 1
```

There is **exactly one way** to be at the starting point (0 steps):

* Do nothing

---

## Fibonacci Insight

You will notice:

```
ways(n) = ways(n - 1) + ways(n - 2)
```

This is exactly the **Fibonacci series**.

---

## Time Complexity Analysis

### Recursive Solution

```
Time: O(2^n)
```

Reason:

* Each state branches into **two recursive calls**
* Exponential growth

---

### Dynamic Programming

```
Time: O(n)
```

Reason:

* Each state is computed **once**
* Stored and reused

---

## DP State Transition Visualization

### Pull DP (Bottom-Up)

Updating **current state** from **past states**

```
dp[i] = dp[i - 1] + dp[i - 2]

dp[0]  dp[1]  dp[2]  dp[3]  dp[4]
  â”‚      â”‚      â”‚      â”‚      â”‚
  â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
```

---

### Push DP

Updating **future states** from **current state**

```
dp[i] â”€â”€â–º dp[i + 1]
  â”‚
  â””â”€â”€â”€â”€â–º dp[i + 2]
```

---

## Types of DP

### Push DP

* Update **future states** using current state

### Pull DP

* Compute **current state** using past states

---

## Solutions

---

### 1. Recursion (TLE)

```java
class Solution {
    public int climbStairs(int n) {
        return ways(n);
    }

    private int ways(int n) {
        if (n == 0) return 1;
        if (n < 0) return 0;

        return ways(n - 1) + ways(n - 2);
    }
}
```

---

### 2. Recursion with Memoization (Top-Down DP)

```java
class Solution {
    int[] dp;

    public int climbStairs(int n) {
        dp = new int[n + 1];
        Arrays.fill(dp, -1);
        return ways(n);
    }

    private int ways(int n) {
        if (n == 0) return 1;
        if (n < 0) return 0;

        if (dp[n] != -1) return dp[n];

        dp[n] = ways(n - 1) + ways(n - 2);
        return dp[n];
    }
}
```

---

### 3. Pull DP (Bottom-Up)

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];

        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
}
```

---

### 4. Push DP

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for (int i = 0; i < n; i++) {
            dp[i + 1] += dp[i];
            if (i + 2 <= n) {
                dp[i + 2] += dp[i];
            }
        }

        return dp[n];
    }
}
```

---

### 5. Space Optimized DP (O(1) Space)

```java
class Solution {
    public int climbStairs(int n) {
        int prev2 = 1; // dp[i-2]
        int prev1 = 1; // dp[i-1]

        for (int i = 2; i <= n; i++) {
            int curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }

        return prev1;
    }
}
```

---

## Summary

| Approach     | Time  | Space |
| ------------ | ----- | ----- |
| Recursion    | O(2â¿) | O(n)  |
| Memoization  | O(n)  | O(n)  |
| Pull DP      | O(n)  | O(n)  |
| Push DP      | O(n)  | O(n)  |
| Optimized DP | O(n)  | O(1)  |

Notes: 
<img width="5627" height="15554" alt="maxdepth-binary-tree" src="https://github.com/user-attachments/assets/c5b64bdc-6c8d-48a9-ac38-260153a0ee66" />

