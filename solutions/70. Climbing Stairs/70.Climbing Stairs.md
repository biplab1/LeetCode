# 70. Climbing Stairs

## Problem Statement

You are climbing a staircase. It takes **`n` steps** to reach the top.

Each time, you can either climb **1 step** or **2 steps**. In how many **distinct ways** can you climb to the top?

### Example 1
- Input:  n = 2 
- Output: 2

Explanation: There are two ways to climb to the top <br>
- 1 step + 1 step <br>
- 2 steps

### Example 2
- Input:  n = 3 <br>
- Output: 3

Explanation: There are three ways to climb to the top <br>
- 1 step + 1 step + 1 step
- 1 step + 2 steps 
- 2 steps + 1 step

## Constraints
1 <= n <= 45

---

## Why DP should be applied here?

1. **Choice at each step**

   * For step `n`, you can come from `n-1` or `n-2`
2. **Overlapping subproblems**

   * Same states (e.g., `ways(2)`, `ways(1)`) are recalculated multiple times
3. **Optimal substructure**

   * `ways(n)` depends on optimal solutions of smaller states

Of course, one can solve a DP problem using recursion but for large values of input, it cannot be solved efficiently due to memory constraint. After all, DP is recursion + memoization.

---

## Recursion Tree (Without DP)

### Example: `n = 3`
<img width="1216" height="572" alt="image" src="https://github.com/user-attachments/assets/161e37bb-2b85-4529-b7c4-028aaa0e3529" />

## Base Case Explanation

```
dp[0] = 1
```

There is indeed only one way to be at the "starting point" (0 steps) - by doing nothing, simply not moving at all. 

---

## Fibonacci Insight

You will notice:

```
ways(n) = ways(n - 1) + ways(n - 2)
```

This is exactly the **Fibonacci series**.

---

## Time Complexity Analysis

### Recursive Solution without memoization

```
Time : O(2^n)
```

Reason:

* There are two possibilities at each state: either you can take 1 step or you take 2 steps. So, recursive solution requires computing both left and right sub-trees.
* For every additional climb each state branch splits into two, which results in an exponential time complexity.
---

### Dynamic Programming

```
Time Complexity: O(n)
```

Reason:

* We keep track of previously solved states, in order to avoid calculating states multiple times
* Ways to 3rd step:
  - 1, 2, 3
  - 0, 2, 3
  - 0, 1, 3
* DP provides mechanism to cache such states

<img width="553" height="426" alt="image" src="https://github.com/user-attachments/assets/c4aee4ca-8be7-4f7f-a117-e51ceadeb1f2" />

---

## Types of DP: Push DP and Pull DP

### Pull DP (Bottom-Up)
Here we calculate current state based on past states

### Push DP
Here we update future state based on current states

<img width="1201" height="365" alt="image" src="https://github.com/user-attachments/assets/bb93e8b1-5154-4bde-9a98-d2da8548aaae" />

---

## Solution types:
* Recursion
* Recursion with memoization
* Push DP
* Pull DP
* DP with Space Complexity SC: O(1)

---

Below is **only the list of programs** present in the image, reproduced **as-is**, without renaming, refactoring, or altering logic, formatting, or comments.
Each block corresponds to one program exactly as shown.

---

## DP with SC O(1)

```java
class Solution {
    public int climbStairs(int n) {
        int a = 1;
        int b = 1;
        int c = 1;

        for (int i = 2; i < n +1; i++) {
            c = a + b;
            b = a;
            a = c;
        }

        return c;
    }
}
```

---

## Pull DP

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];

        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i < n + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
}
```

---

## Pull DP

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];

        dp[0] = 1;

        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1];
            if (i - 2 >= 0) {
                dp[i] += dp[i - 2];
            }
        }

        return dp[n];
    }
}
```

---

## Push DP

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for (int i = 0; i < n; i++) {
            dp[i + 1] += dp[i];
            if (i + 2 <= n) {
                dp[i + 2] += dp[i];
            }
        }

        return dp[n];
    }
}
```

---

## Recursion with memoization

```java
class Solution {
    int[] dp;

    public int climbStairs(int n) {
        dp = new int[n + 1];
        Arrays.fill(dp, -1);
        return ways(n);
    }

    private int ways(int n) {
        if (n == 0) return 1;
        if (n == 1) return 1;

        if (dp[n] != -1) return dp[n];

        dp[n] = ways(n - 1) + ways(n - 2);
        return dp[n];
    }
}
```

---

## Recursion with memoization (intuitive)

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, -1);
        return ways(0, n, dp);
    }

    private int ways(int start, int n, int[] dp) {
        if (start == n) {
            return 1;
        }

        if (start > n) {
            return 0;
        }

        if (dp[start] != -1) {
            return dp[start];
        }

        return dp[start] =
            ways(start + 1, n, dp) +
            ways(start + 2, n, dp);
    }
}
```

---

## Recursion (TLE)

```java
class Solution {
    public int climbStairs(int n) {
        return ways(n);
    }

    private int ways(int n) {
        if (n == 0) return 1;
        if (n < 0) return 0;

        return ways(n - 1) + ways(n - 2);
    }
}
```

---

## Recursion with memoization – Pull DP

```java
class Solution {
    int[] dp;

    public int climbStairs(int n) {
        dp = new int[n + 1];
        Arrays.fill(dp, -1);
        return ways(n);
    }

    private int ways(int n) {
        if (n == 0) return 1;
        if (n < 0) return 0;

        if (dp[n] != -1) return dp[n];

        return dp[n] = ways(n - 1) + ways(n - 2);
    }
}
```

---

## Recursion (TLE – shorter form)

```java
class Solution {
    public int climbStairs(int n) {
        return ways(n);
    }

    private int ways(int n) {
        if (n == 0) return 1;
        if (n < 0) return 0;

        return ways(n - 1) + ways(n - 2);
    }
}
```

---

## Summary

| Approach     | Time  | Space |
| ------------ | ----- | ----- |
| Recursion    | O(2ⁿ) | O(n)  | <-- Height of binary tree (stack space)
| Memoization  | O(n)  | O(n)  |
| Pull DP      | O(n)  | O(n)  | <- Array size
| Push DP      | O(n)  | O(n)  |
| Optimized DP | O(n)  | O(1)  |
